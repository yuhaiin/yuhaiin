// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api/api.proto

package api

import (
	context "context"
	fmt "fmt"
	config "github.com/Asutorufa/yuhaiin/config"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type DaUaDrUr struct {
	Download             string   `protobuf:"bytes,1,opt,name=Download,proto3" json:"Download,omitempty"`
	Upload               string   `protobuf:"bytes,2,opt,name=Upload,proto3" json:"Upload,omitempty"`
	DownRate             string   `protobuf:"bytes,3,opt,name=DownRate,proto3" json:"DownRate,omitempty"`
	UpRate               string   `protobuf:"bytes,4,opt,name=UpRate,proto3" json:"UpRate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaUaDrUr) Reset()         { *m = DaUaDrUr{} }
func (m *DaUaDrUr) String() string { return proto.CompactTextString(m) }
func (*DaUaDrUr) ProtoMessage()    {}
func (*DaUaDrUr) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{0}
}

func (m *DaUaDrUr) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DaUaDrUr.Unmarshal(m, b)
}
func (m *DaUaDrUr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DaUaDrUr.Marshal(b, m, deterministic)
}
func (m *DaUaDrUr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaUaDrUr.Merge(m, src)
}
func (m *DaUaDrUr) XXX_Size() int {
	return xxx_messageInfo_DaUaDrUr.Size(m)
}
func (m *DaUaDrUr) XXX_DiscardUnknown() {
	xxx_messageInfo_DaUaDrUr.DiscardUnknown(m)
}

var xxx_messageInfo_DaUaDrUr proto.InternalMessageInfo

func (m *DaUaDrUr) GetDownload() string {
	if m != nil {
		return m.Download
	}
	return ""
}

func (m *DaUaDrUr) GetUpload() string {
	if m != nil {
		return m.Upload
	}
	return ""
}

func (m *DaUaDrUr) GetDownRate() string {
	if m != nil {
		return m.DownRate
	}
	return ""
}

func (m *DaUaDrUr) GetUpRate() string {
	if m != nil {
		return m.UpRate
	}
	return ""
}

type NodeMap struct {
	Value                map[string]string `protobuf:"bytes,1,rep,name=Value,proto3" json:"Value,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *NodeMap) Reset()         { *m = NodeMap{} }
func (m *NodeMap) String() string { return proto.CompactTextString(m) }
func (*NodeMap) ProtoMessage()    {}
func (*NodeMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{1}
}

func (m *NodeMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeMap.Unmarshal(m, b)
}
func (m *NodeMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeMap.Marshal(b, m, deterministic)
}
func (m *NodeMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeMap.Merge(m, src)
}
func (m *NodeMap) XXX_Size() int {
	return xxx_messageInfo_NodeMap.Size(m)
}
func (m *NodeMap) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeMap.DiscardUnknown(m)
}

var xxx_messageInfo_NodeMap proto.InternalMessageInfo

func (m *NodeMap) GetValue() map[string]string {
	if m != nil {
		return m.Value
	}
	return nil
}

type Nodes struct {
	Value                map[string]*AllGroupOrNode `protobuf:"bytes,1,rep,name=value,proto3" json:"value,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *Nodes) Reset()         { *m = Nodes{} }
func (m *Nodes) String() string { return proto.CompactTextString(m) }
func (*Nodes) ProtoMessage()    {}
func (*Nodes) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{2}
}

func (m *Nodes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Nodes.Unmarshal(m, b)
}
func (m *Nodes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Nodes.Marshal(b, m, deterministic)
}
func (m *Nodes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Nodes.Merge(m, src)
}
func (m *Nodes) XXX_Size() int {
	return xxx_messageInfo_Nodes.Size(m)
}
func (m *Nodes) XXX_DiscardUnknown() {
	xxx_messageInfo_Nodes.DiscardUnknown(m)
}

var xxx_messageInfo_Nodes proto.InternalMessageInfo

func (m *Nodes) GetValue() map[string]*AllGroupOrNode {
	if m != nil {
		return m.Value
	}
	return nil
}

type AllGroupOrNode struct {
	Value                []string `protobuf:"bytes,1,rep,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllGroupOrNode) Reset()         { *m = AllGroupOrNode{} }
func (m *AllGroupOrNode) String() string { return proto.CompactTextString(m) }
func (*AllGroupOrNode) ProtoMessage()    {}
func (*AllGroupOrNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{3}
}

func (m *AllGroupOrNode) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AllGroupOrNode.Unmarshal(m, b)
}
func (m *AllGroupOrNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AllGroupOrNode.Marshal(b, m, deterministic)
}
func (m *AllGroupOrNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllGroupOrNode.Merge(m, src)
}
func (m *AllGroupOrNode) XXX_Size() int {
	return xxx_messageInfo_AllGroupOrNode.Size(m)
}
func (m *AllGroupOrNode) XXX_DiscardUnknown() {
	xxx_messageInfo_AllGroupOrNode.DiscardUnknown(m)
}

var xxx_messageInfo_AllGroupOrNode proto.InternalMessageInfo

func (m *AllGroupOrNode) GetValue() []string {
	if m != nil {
		return m.Value
	}
	return nil
}

type GroupAndNode struct {
	Group                string   `protobuf:"bytes,1,opt,name=group,proto3" json:"group,omitempty"`
	Node                 string   `protobuf:"bytes,2,opt,name=node,proto3" json:"node,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GroupAndNode) Reset()         { *m = GroupAndNode{} }
func (m *GroupAndNode) String() string { return proto.CompactTextString(m) }
func (*GroupAndNode) ProtoMessage()    {}
func (*GroupAndNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{4}
}

func (m *GroupAndNode) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GroupAndNode.Unmarshal(m, b)
}
func (m *GroupAndNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GroupAndNode.Marshal(b, m, deterministic)
}
func (m *GroupAndNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupAndNode.Merge(m, src)
}
func (m *GroupAndNode) XXX_Size() int {
	return xxx_messageInfo_GroupAndNode.Size(m)
}
func (m *GroupAndNode) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupAndNode.DiscardUnknown(m)
}

var xxx_messageInfo_GroupAndNode proto.InternalMessageInfo

func (m *GroupAndNode) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *GroupAndNode) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

type Link struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Url                  string   `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	Type                 string   `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Link) Reset()         { *m = Link{} }
func (m *Link) String() string { return proto.CompactTextString(m) }
func (*Link) ProtoMessage()    {}
func (*Link) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{5}
}

func (m *Link) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Link.Unmarshal(m, b)
}
func (m *Link) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Link.Marshal(b, m, deterministic)
}
func (m *Link) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link.Merge(m, src)
}
func (m *Link) XXX_Size() int {
	return xxx_messageInfo_Link.Size(m)
}
func (m *Link) XXX_DiscardUnknown() {
	xxx_messageInfo_Link.DiscardUnknown(m)
}

var xxx_messageInfo_Link proto.InternalMessageInfo

func (m *Link) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Link) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Link) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type Links struct {
	Value                map[string]*Link `protobuf:"bytes,1,rep,name=Value,proto3" json:"Value,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Links) Reset()         { *m = Links{} }
func (m *Links) String() string { return proto.CompactTextString(m) }
func (*Links) ProtoMessage()    {}
func (*Links) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{6}
}

func (m *Links) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Links.Unmarshal(m, b)
}
func (m *Links) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Links.Marshal(b, m, deterministic)
}
func (m *Links) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Links.Merge(m, src)
}
func (m *Links) XXX_Size() int {
	return xxx_messageInfo_Links.Size(m)
}
func (m *Links) XXX_DiscardUnknown() {
	xxx_messageInfo_Links.DiscardUnknown(m)
}

var xxx_messageInfo_Links proto.InternalMessageInfo

func (m *Links) GetValue() map[string]*Link {
	if m != nil {
		return m.Value
	}
	return nil
}

func init() {
	proto.RegisterType((*DaUaDrUr)(nil), "yuhaiin.api.DaUaDrUr")
	proto.RegisterType((*NodeMap)(nil), "yuhaiin.api.nodeMap")
	proto.RegisterMapType((map[string]string)(nil), "yuhaiin.api.nodeMap.ValueEntry")
	proto.RegisterType((*Nodes)(nil), "yuhaiin.api.nodes")
	proto.RegisterMapType((map[string]*AllGroupOrNode)(nil), "yuhaiin.api.nodes.ValueEntry")
	proto.RegisterType((*AllGroupOrNode)(nil), "yuhaiin.api.allGroupOrNode")
	proto.RegisterType((*GroupAndNode)(nil), "yuhaiin.api.GroupAndNode")
	proto.RegisterType((*Link)(nil), "yuhaiin.api.Link")
	proto.RegisterType((*Links)(nil), "yuhaiin.api.Links")
	proto.RegisterMapType((map[string]*Link)(nil), "yuhaiin.api.Links.ValueEntry")
}

func init() {
	proto.RegisterFile("api/api.proto", fileDescriptor_1b40cafcd4234784)
}

var fileDescriptor_1b40cafcd4234784 = []byte{
	// 811 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdd, 0x72, 0xe2, 0x36,
	0x14, 0x1e, 0x6f, 0x20, 0xc0, 0x21, 0x61, 0x5a, 0x75, 0xbb, 0x93, 0xb2, 0xfd, 0xc9, 0x70, 0xd1,
	0xe6, 0xca, 0x6c, 0xc9, 0xb4, 0xcd, 0xa6, 0x3f, 0xbb, 0x04, 0xb2, 0x34, 0xb3, 0xd9, 0x6c, 0x06,
	0x0f, 0x7b, 0xd1, 0x3b, 0x81, 0x0f, 0x8e, 0x26, 0x46, 0xf2, 0xc8, 0x72, 0x29, 0x7d, 0x83, 0x5e,
	0xf7, 0x21, 0xfa, 0x32, 0x7d, 0xa2, 0xf6, 0xa6, 0x63, 0xc9, 0x4e, 0x70, 0xc1, 0x4e, 0xa1, 0x57,
	0xe8, 0xe8, 0x7c, 0xdf, 0xa7, 0xf3, 0x23, 0x1f, 0x01, 0xfb, 0x34, 0x60, 0x6d, 0x1a, 0x30, 0x3b,
	0x90, 0x42, 0x09, 0x52, 0x5f, 0x44, 0x37, 0x94, 0x31, 0x6e, 0xd3, 0x80, 0x35, 0x9f, 0x7a, 0x42,
	0x78, 0x3e, 0xb6, 0xb5, 0x6b, 0x1c, 0x4d, 0xdb, 0x38, 0x0b, 0xd4, 0xc2, 0x20, 0x9b, 0x9f, 0xfe,
	0xdb, 0x39, 0x97, 0x34, 0x08, 0x50, 0x86, 0x89, 0xff, 0x83, 0x89, 0xe0, 0x53, 0xe6, 0xb5, 0xcd,
	0x8f, 0xd9, 0x6c, 0x49, 0xa8, 0xf6, 0xe9, 0x88, 0xf6, 0xe5, 0x48, 0x92, 0x26, 0x54, 0xfb, 0x62,
	0xce, 0x7d, 0x41, 0xdd, 0x03, 0xeb, 0xd0, 0x3a, 0xaa, 0x0d, 0xef, 0x6c, 0xf2, 0x04, 0x76, 0x47,
	0x81, 0xf6, 0x3c, 0xd2, 0x9e, 0xc4, 0x4a, 0x39, 0x43, 0xaa, 0xf0, 0x60, 0xe7, 0x9e, 0x13, 0xdb,
	0x86, 0xa3, 0x3d, 0xa5, 0x94, 0x13, 0x5b, 0xad, 0x5f, 0xa1, 0xc2, 0x85, 0x8b, 0x6f, 0x68, 0x40,
	0xbe, 0x82, 0xf2, 0x3b, 0xea, 0x47, 0x78, 0x60, 0x1d, 0xee, 0x1c, 0xd5, 0x3b, 0x9f, 0xd9, 0x4b,
	0xd9, 0xda, 0x09, 0xc8, 0xd6, 0x88, 0x73, 0xae, 0xe4, 0x62, 0x68, 0xd0, 0xcd, 0x13, 0x80, 0xfb,
	0x4d, 0xf2, 0x1e, 0xec, 0xdc, 0xe2, 0x22, 0x09, 0x39, 0x5e, 0x92, 0xc7, 0x50, 0xfe, 0x59, 0xcb,
	0x9a, 0x60, 0x8d, 0x71, 0xfa, 0xe8, 0xc4, 0x6a, 0xfd, 0x6e, 0x41, 0x39, 0xd6, 0x0d, 0xc9, 0x71,
	0x8a, 0x31, 0x47, 0x7f, 0xb2, 0x72, 0x74, 0x98, 0x39, 0x58, 0x63, 0x9b, 0xa3, 0x07, 0x0e, 0xfe,
	0x72, 0xf9, 0xe0, 0x7a, 0xe7, 0x69, 0x46, 0x94, 0xfa, 0xfe, 0x40, 0x8a, 0x28, 0x78, 0x2b, 0xaf,
	0x84, 0x8b, 0xcb, 0x51, 0x7d, 0x0e, 0x8d, 0xac, 0xf3, 0x3e, 0x83, 0x38, 0xba, 0x34, 0x83, 0xd6,
	0x09, 0xec, 0x69, 0x50, 0x97, 0xbb, 0x29, 0xca, 0x8b, 0xed, 0x24, 0x04, 0x63, 0x10, 0x02, 0xa5,
	0x38, 0xfe, 0x24, 0x79, 0xbd, 0x6e, 0xbd, 0x84, 0xd2, 0x25, 0xe3, 0xb7, 0xda, 0x47, 0x67, 0x98,
	0x10, 0xf4, 0x3a, 0x4e, 0x23, 0x92, 0x7e, 0x02, 0x8f, 0x97, 0x31, 0x4a, 0x2d, 0x82, 0xb4, 0xa3,
	0x7a, 0xdd, 0xfa, 0xcd, 0x82, 0x72, 0x2c, 0xa1, 0x2b, 0xf7, 0x2e, 0xb7, 0x72, 0x1a, 0xb2, 0xa6,
	0x65, 0xaf, 0x1f, 0xa8, 0xdc, 0x17, 0xd9, 0xca, 0xbd, 0xbf, 0x22, 0xba, 0x54, 0xaf, 0xce, 0x1f,
	0x25, 0xa8, 0x07, 0x52, 0x4c, 0x30, 0x0c, 0x2f, 0x38, 0x53, 0xe4, 0x25, 0x34, 0x7a, 0x12, 0xa9,
	0xc2, 0x4b, 0x31, 0xb9, 0x7d, 0xc5, 0x7c, 0x24, 0x4f, 0x6c, 0xf3, 0x35, 0xd8, 0xe9, 0xd7, 0x60,
	0x9f, 0xc7, 0x9f, 0x4a, 0x33, 0x67, 0x9f, 0x7c, 0x0f, 0xf5, 0xeb, 0x25, 0xc1, 0x4d, 0xe9, 0xaf,
	0xa0, 0x31, 0x40, 0x35, 0x8c, 0x38, 0x67, 0xdc, 0xfb, 0x51, 0x84, 0xf9, 0x0a, 0x1f, 0xaf, 0xec,
	0x3b, 0x4a, 0x32, 0xee, 0xe9, 0xe2, 0x90, 0x53, 0xa8, 0xf6, 0x7c, 0x86, 0x5c, 0xbd, 0xe5, 0xff,
	0x23, 0x85, 0xf3, 0x5f, 0xb6, 0x48, 0xa1, 0x0f, 0x7b, 0x03, 0x54, 0xaf, 0x51, 0x72, 0xf4, 0xaf,
	0x99, 0xbb, 0x41, 0x02, 0xa3, 0x0b, 0xae, 0x8e, 0x3b, 0x26, 0x81, 0xef, 0x00, 0x1c, 0x25, 0x02,
	0x23, 0xb3, 0x71, 0x0c, 0xd7, 0xd0, 0x70, 0x18, 0xf7, 0x7c, 0xbc, 0xe0, 0xa1, 0xa2, 0x7c, 0x82,
	0xa4, 0xb0, 0x5c, 0xc5, 0xc5, 0x3c, 0xb2, 0x9e, 0x59, 0x9d, 0xbf, 0x2c, 0xd8, 0x35, 0x03, 0x8f,
	0x3c, 0x87, 0xda, 0x00, 0x55, 0xcf, 0x18, 0x79, 0x91, 0x3d, 0xce, 0xdc, 0x3b, 0x07, 0x95, 0x62,
	0x5c, 0x53, 0x9d, 0x3b, 0xea, 0x5a, 0x48, 0x6e, 0x4a, 0x3f, 0xc0, 0xde, 0x10, 0xd9, 0x2c, 0x10,
	0x52, 0x0d, 0xa3, 0x2d, 0x2e, 0xe6, 0x29, 0x54, 0x3c, 0x54, 0x66, 0x9e, 0xe6, 0x50, 0x3f, 0xcc,
	0x04, 0x94, 0x8e, 0xf3, 0x67, 0x56, 0xe7, 0xcf, 0x12, 0x94, 0xf4, 0x9c, 0xf8, 0x1a, 0xaa, 0x03,
	0x54, 0x57, 0x7a, 0xee, 0xe5, 0xa9, 0x90, 0xd5, 0x01, 0x48, 0x5e, 0x68, 0x9e, 0x1e, 0x39, 0xb9,
	0xbc, 0xa2, 0x19, 0x47, 0xfa, 0x50, 0x49, 0x0e, 0x7e, 0xa0, 0x93, 0x85, 0x2a, 0x03, 0x20, 0x5a,
	0x65, 0x7e, 0x37, 0xfc, 0xe2, 0xb1, 0x95, 0x17, 0xd0, 0x47, 0x19, 0xa9, 0xcc, 0xbc, 0x3c, 0x83,
	0xfd, 0xde, 0x0d, 0xe5, 0x1e, 0x5e, 0x89, 0xb9, 0xde, 0xc8, 0xc7, 0xe6, 0x36, 0xe4, 0x1b, 0xa8,
	0x74, 0xdd, 0x64, 0xfc, 0xae, 0x7b, 0xae, 0x0a, 0x3a, 0x09, 0x6f, 0x84, 0xcb, 0xa6, 0x8b, 0x2d,
	0xb8, 0x2f, 0x00, 0xfa, 0xe8, 0xa3, 0xc2, 0x6d, 0xa3, 0x3e, 0x83, 0xca, 0x25, 0x55, 0xc8, 0x27,
	0x8b, 0x22, 0x76, 0x61, 0x8f, 0x3a, 0x7f, 0x5b, 0x50, 0x73, 0xa2, 0x71, 0x38, 0x91, 0x6c, 0x8c,
	0xe4, 0x5b, 0xa8, 0x8d, 0x02, 0x97, 0x2a, 0x74, 0xa2, 0xf1, 0xc6, 0xb7, 0xfa, 0x39, 0xd4, 0x07,
	0xa8, 0x9c, 0x68, 0x6c, 0x5e, 0x94, 0xff, 0x76, 0x27, 0xd3, 0xd7, 0x07, 0xba, 0xae, 0x9b, 0x50,
	0xc9, 0xea, 0x3b, 0xb1, 0x96, 0xd4, 0x85, 0x7d, 0x53, 0xbf, 0x94, 0x57, 0x7c, 0x1b, 0xd7, 0x48,
	0x9c, 0xb5, 0x7e, 0x3a, 0xf4, 0x98, 0xba, 0x89, 0xc6, 0xf6, 0x44, 0xcc, 0xda, 0xdd, 0x30, 0x52,
	0x42, 0x46, 0x53, 0xda, 0x4e, 0x90, 0xf1, 0x5f, 0xb6, 0xf1, 0xae, 0x56, 0x3b, 0xfe, 0x27, 0x00,
	0x00, 0xff, 0xff, 0x60, 0xd7, 0x55, 0xd2, 0xc4, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ProcessInitClient is the client API for ProcessInit service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ProcessInitClient interface {
	CreateLockFile(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	ProcessInit(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	GetRunningHost(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*wrappers.StringValue, error)
	ClientOn(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	ProcessExit(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	GetKernelPid(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*wrappers.UInt32Value, error)
	StopKernel(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	SingleInstance(ctx context.Context, opts ...grpc.CallOption) (ProcessInit_SingleInstanceClient, error)
}

type processInitClient struct {
	cc grpc.ClientConnInterface
}

func NewProcessInitClient(cc grpc.ClientConnInterface) ProcessInitClient {
	return &processInitClient{cc}
}

func (c *processInitClient) CreateLockFile(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.processInit/CreateLockFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processInitClient) ProcessInit(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.processInit/ProcessInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processInitClient) GetRunningHost(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*wrappers.StringValue, error) {
	out := new(wrappers.StringValue)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.processInit/GetRunningHost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processInitClient) ClientOn(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.processInit/ClientOn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processInitClient) ProcessExit(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.processInit/ProcessExit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processInitClient) GetKernelPid(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*wrappers.UInt32Value, error) {
	out := new(wrappers.UInt32Value)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.processInit/GetKernelPid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processInitClient) StopKernel(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.processInit/StopKernel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processInitClient) SingleInstance(ctx context.Context, opts ...grpc.CallOption) (ProcessInit_SingleInstanceClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ProcessInit_serviceDesc.Streams[0], "/yuhaiin.api.processInit/SingleInstance", opts...)
	if err != nil {
		return nil, err
	}
	x := &processInitSingleInstanceClient{stream}
	return x, nil
}

type ProcessInit_SingleInstanceClient interface {
	Send(*wrappers.StringValue) error
	Recv() (*wrappers.StringValue, error)
	grpc.ClientStream
}

type processInitSingleInstanceClient struct {
	grpc.ClientStream
}

func (x *processInitSingleInstanceClient) Send(m *wrappers.StringValue) error {
	return x.ClientStream.SendMsg(m)
}

func (x *processInitSingleInstanceClient) Recv() (*wrappers.StringValue, error) {
	m := new(wrappers.StringValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ProcessInitServer is the server API for ProcessInit service.
type ProcessInitServer interface {
	CreateLockFile(context.Context, *empty.Empty) (*empty.Empty, error)
	ProcessInit(context.Context, *empty.Empty) (*empty.Empty, error)
	GetRunningHost(context.Context, *empty.Empty) (*wrappers.StringValue, error)
	ClientOn(context.Context, *empty.Empty) (*empty.Empty, error)
	ProcessExit(context.Context, *empty.Empty) (*empty.Empty, error)
	GetKernelPid(context.Context, *empty.Empty) (*wrappers.UInt32Value, error)
	StopKernel(context.Context, *empty.Empty) (*empty.Empty, error)
	SingleInstance(ProcessInit_SingleInstanceServer) error
}

// UnimplementedProcessInitServer can be embedded to have forward compatible implementations.
type UnimplementedProcessInitServer struct {
}

func (*UnimplementedProcessInitServer) CreateLockFile(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLockFile not implemented")
}
func (*UnimplementedProcessInitServer) ProcessInit(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessInit not implemented")
}
func (*UnimplementedProcessInitServer) GetRunningHost(ctx context.Context, req *empty.Empty) (*wrappers.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRunningHost not implemented")
}
func (*UnimplementedProcessInitServer) ClientOn(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClientOn not implemented")
}
func (*UnimplementedProcessInitServer) ProcessExit(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessExit not implemented")
}
func (*UnimplementedProcessInitServer) GetKernelPid(ctx context.Context, req *empty.Empty) (*wrappers.UInt32Value, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKernelPid not implemented")
}
func (*UnimplementedProcessInitServer) StopKernel(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopKernel not implemented")
}
func (*UnimplementedProcessInitServer) SingleInstance(srv ProcessInit_SingleInstanceServer) error {
	return status.Errorf(codes.Unimplemented, "method SingleInstance not implemented")
}

func RegisterProcessInitServer(s *grpc.Server, srv ProcessInitServer) {
	s.RegisterService(&_ProcessInit_serviceDesc, srv)
}

func _ProcessInit_CreateLockFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessInitServer).CreateLockFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.processInit/CreateLockFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessInitServer).CreateLockFile(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessInit_ProcessInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessInitServer).ProcessInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.processInit/ProcessInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessInitServer).ProcessInit(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessInit_GetRunningHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessInitServer).GetRunningHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.processInit/GetRunningHost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessInitServer).GetRunningHost(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessInit_ClientOn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessInitServer).ClientOn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.processInit/ClientOn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessInitServer).ClientOn(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessInit_ProcessExit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessInitServer).ProcessExit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.processInit/ProcessExit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessInitServer).ProcessExit(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessInit_GetKernelPid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessInitServer).GetKernelPid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.processInit/GetKernelPid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessInitServer).GetKernelPid(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessInit_StopKernel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessInitServer).StopKernel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.processInit/StopKernel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessInitServer).StopKernel(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessInit_SingleInstance_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ProcessInitServer).SingleInstance(&processInitSingleInstanceServer{stream})
}

type ProcessInit_SingleInstanceServer interface {
	Send(*wrappers.StringValue) error
	Recv() (*wrappers.StringValue, error)
	grpc.ServerStream
}

type processInitSingleInstanceServer struct {
	grpc.ServerStream
}

func (x *processInitSingleInstanceServer) Send(m *wrappers.StringValue) error {
	return x.ServerStream.SendMsg(m)
}

func (x *processInitSingleInstanceServer) Recv() (*wrappers.StringValue, error) {
	m := new(wrappers.StringValue)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ProcessInit_serviceDesc = grpc.ServiceDesc{
	ServiceName: "yuhaiin.api.processInit",
	HandlerType: (*ProcessInitServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateLockFile",
			Handler:    _ProcessInit_CreateLockFile_Handler,
		},
		{
			MethodName: "ProcessInit",
			Handler:    _ProcessInit_ProcessInit_Handler,
		},
		{
			MethodName: "GetRunningHost",
			Handler:    _ProcessInit_GetRunningHost_Handler,
		},
		{
			MethodName: "ClientOn",
			Handler:    _ProcessInit_ClientOn_Handler,
		},
		{
			MethodName: "ProcessExit",
			Handler:    _ProcessInit_ProcessExit_Handler,
		},
		{
			MethodName: "GetKernelPid",
			Handler:    _ProcessInit_GetKernelPid_Handler,
		},
		{
			MethodName: "StopKernel",
			Handler:    _ProcessInit_StopKernel_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SingleInstance",
			Handler:       _ProcessInit_SingleInstance_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "api/api.proto",
}

// ConfigClient is the client API for Config service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ConfigClient interface {
	GetConfig(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*config.Setting, error)
	SetConfig(ctx context.Context, in *config.Setting, opts ...grpc.CallOption) (*empty.Empty, error)
	ReimportRule(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	GetRate(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (Config_GetRateClient, error)
}

type configClient struct {
	cc grpc.ClientConnInterface
}

func NewConfigClient(cc grpc.ClientConnInterface) ConfigClient {
	return &configClient{cc}
}

func (c *configClient) GetConfig(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*config.Setting, error) {
	out := new(config.Setting)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.config/GetConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configClient) SetConfig(ctx context.Context, in *config.Setting, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.config/SetConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configClient) ReimportRule(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.config/ReimportRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configClient) GetRate(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (Config_GetRateClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Config_serviceDesc.Streams[0], "/yuhaiin.api.config/getRate", opts...)
	if err != nil {
		return nil, err
	}
	x := &configGetRateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Config_GetRateClient interface {
	Recv() (*DaUaDrUr, error)
	grpc.ClientStream
}

type configGetRateClient struct {
	grpc.ClientStream
}

func (x *configGetRateClient) Recv() (*DaUaDrUr, error) {
	m := new(DaUaDrUr)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ConfigServer is the server API for Config service.
type ConfigServer interface {
	GetConfig(context.Context, *empty.Empty) (*config.Setting, error)
	SetConfig(context.Context, *config.Setting) (*empty.Empty, error)
	ReimportRule(context.Context, *empty.Empty) (*empty.Empty, error)
	GetRate(*empty.Empty, Config_GetRateServer) error
}

// UnimplementedConfigServer can be embedded to have forward compatible implementations.
type UnimplementedConfigServer struct {
}

func (*UnimplementedConfigServer) GetConfig(ctx context.Context, req *empty.Empty) (*config.Setting, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfig not implemented")
}
func (*UnimplementedConfigServer) SetConfig(ctx context.Context, req *config.Setting) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetConfig not implemented")
}
func (*UnimplementedConfigServer) ReimportRule(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReimportRule not implemented")
}
func (*UnimplementedConfigServer) GetRate(req *empty.Empty, srv Config_GetRateServer) error {
	return status.Errorf(codes.Unimplemented, "method GetRate not implemented")
}

func RegisterConfigServer(s *grpc.Server, srv ConfigServer) {
	s.RegisterService(&_Config_serviceDesc, srv)
}

func _Config_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.config/GetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServer).GetConfig(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Config_SetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(config.Setting)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServer).SetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.config/SetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServer).SetConfig(ctx, req.(*config.Setting))
	}
	return interceptor(ctx, in, info, handler)
}

func _Config_ReimportRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServer).ReimportRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.config/ReimportRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServer).ReimportRule(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Config_GetRate_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(empty.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConfigServer).GetRate(m, &configGetRateServer{stream})
}

type Config_GetRateServer interface {
	Send(*DaUaDrUr) error
	grpc.ServerStream
}

type configGetRateServer struct {
	grpc.ServerStream
}

func (x *configGetRateServer) Send(m *DaUaDrUr) error {
	return x.ServerStream.SendMsg(m)
}

var _Config_serviceDesc = grpc.ServiceDesc{
	ServiceName: "yuhaiin.api.config",
	HandlerType: (*ConfigServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConfig",
			Handler:    _Config_GetConfig_Handler,
		},
		{
			MethodName: "SetConfig",
			Handler:    _Config_SetConfig_Handler,
		},
		{
			MethodName: "ReimportRule",
			Handler:    _Config_ReimportRule_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "getRate",
			Handler:       _Config_GetRate_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/api.proto",
}

// NodeClient is the client API for Node service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NodeClient interface {
	GetNodes(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Nodes, error)
	GetGroup(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*AllGroupOrNode, error)
	GetNode(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*AllGroupOrNode, error)
	GetNowGroupAndName(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GroupAndNode, error)
	ChangeNowNode(ctx context.Context, in *GroupAndNode, opts ...grpc.CallOption) (*empty.Empty, error)
	AddNode(ctx context.Context, in *NodeMap, opts ...grpc.CallOption) (*empty.Empty, error)
	ModifyNode(ctx context.Context, in *NodeMap, opts ...grpc.CallOption) (*empty.Empty, error)
	DeleteNode(ctx context.Context, in *GroupAndNode, opts ...grpc.CallOption) (*empty.Empty, error)
	Latency(ctx context.Context, in *GroupAndNode, opts ...grpc.CallOption) (*wrappers.StringValue, error)
}

type nodeClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeClient(cc grpc.ClientConnInterface) NodeClient {
	return &nodeClient{cc}
}

func (c *nodeClient) GetNodes(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Nodes, error) {
	out := new(Nodes)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Node/GetNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetGroup(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*AllGroupOrNode, error) {
	out := new(AllGroupOrNode)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Node/GetGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetNode(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*AllGroupOrNode, error) {
	out := new(AllGroupOrNode)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Node/GetNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetNowGroupAndName(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GroupAndNode, error) {
	out := new(GroupAndNode)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Node/GetNowGroupAndName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ChangeNowNode(ctx context.Context, in *GroupAndNode, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Node/ChangeNowNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) AddNode(ctx context.Context, in *NodeMap, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Node/AddNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ModifyNode(ctx context.Context, in *NodeMap, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Node/ModifyNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) DeleteNode(ctx context.Context, in *GroupAndNode, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Node/DeleteNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) Latency(ctx context.Context, in *GroupAndNode, opts ...grpc.CallOption) (*wrappers.StringValue, error) {
	out := new(wrappers.StringValue)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Node/Latency", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeServer is the server API for Node service.
type NodeServer interface {
	GetNodes(context.Context, *empty.Empty) (*Nodes, error)
	GetGroup(context.Context, *empty.Empty) (*AllGroupOrNode, error)
	GetNode(context.Context, *wrappers.StringValue) (*AllGroupOrNode, error)
	GetNowGroupAndName(context.Context, *empty.Empty) (*GroupAndNode, error)
	ChangeNowNode(context.Context, *GroupAndNode) (*empty.Empty, error)
	AddNode(context.Context, *NodeMap) (*empty.Empty, error)
	ModifyNode(context.Context, *NodeMap) (*empty.Empty, error)
	DeleteNode(context.Context, *GroupAndNode) (*empty.Empty, error)
	Latency(context.Context, *GroupAndNode) (*wrappers.StringValue, error)
}

// UnimplementedNodeServer can be embedded to have forward compatible implementations.
type UnimplementedNodeServer struct {
}

func (*UnimplementedNodeServer) GetNodes(ctx context.Context, req *empty.Empty) (*Nodes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodes not implemented")
}
func (*UnimplementedNodeServer) GetGroup(ctx context.Context, req *empty.Empty) (*AllGroupOrNode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGroup not implemented")
}
func (*UnimplementedNodeServer) GetNode(ctx context.Context, req *wrappers.StringValue) (*AllGroupOrNode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNode not implemented")
}
func (*UnimplementedNodeServer) GetNowGroupAndName(ctx context.Context, req *empty.Empty) (*GroupAndNode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNowGroupAndName not implemented")
}
func (*UnimplementedNodeServer) ChangeNowNode(ctx context.Context, req *GroupAndNode) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeNowNode not implemented")
}
func (*UnimplementedNodeServer) AddNode(ctx context.Context, req *NodeMap) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddNode not implemented")
}
func (*UnimplementedNodeServer) ModifyNode(ctx context.Context, req *NodeMap) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyNode not implemented")
}
func (*UnimplementedNodeServer) DeleteNode(ctx context.Context, req *GroupAndNode) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNode not implemented")
}
func (*UnimplementedNodeServer) Latency(ctx context.Context, req *GroupAndNode) (*wrappers.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Latency not implemented")
}

func RegisterNodeServer(s *grpc.Server, srv NodeServer) {
	s.RegisterService(&_Node_serviceDesc, srv)
}

func _Node_GetNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Node/GetNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetNodes(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Node/GetGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetGroup(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrappers.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Node/GetNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetNode(ctx, req.(*wrappers.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetNowGroupAndName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetNowGroupAndName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Node/GetNowGroupAndName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetNowGroupAndName(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ChangeNowNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupAndNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ChangeNowNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Node/ChangeNowNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ChangeNowNode(ctx, req.(*GroupAndNode))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_AddNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeMap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).AddNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Node/AddNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).AddNode(ctx, req.(*NodeMap))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ModifyNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeMap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ModifyNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Node/ModifyNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ModifyNode(ctx, req.(*NodeMap))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_DeleteNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupAndNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).DeleteNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Node/DeleteNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).DeleteNode(ctx, req.(*GroupAndNode))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_Latency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupAndNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).Latency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Node/Latency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).Latency(ctx, req.(*GroupAndNode))
	}
	return interceptor(ctx, in, info, handler)
}

var _Node_serviceDesc = grpc.ServiceDesc{
	ServiceName: "yuhaiin.api.Node",
	HandlerType: (*NodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNodes",
			Handler:    _Node_GetNodes_Handler,
		},
		{
			MethodName: "GetGroup",
			Handler:    _Node_GetGroup_Handler,
		},
		{
			MethodName: "GetNode",
			Handler:    _Node_GetNode_Handler,
		},
		{
			MethodName: "GetNowGroupAndName",
			Handler:    _Node_GetNowGroupAndName_Handler,
		},
		{
			MethodName: "ChangeNowNode",
			Handler:    _Node_ChangeNowNode_Handler,
		},
		{
			MethodName: "AddNode",
			Handler:    _Node_AddNode_Handler,
		},
		{
			MethodName: "ModifyNode",
			Handler:    _Node_ModifyNode_Handler,
		},
		{
			MethodName: "DeleteNode",
			Handler:    _Node_DeleteNode_Handler,
		},
		{
			MethodName: "Latency",
			Handler:    _Node_Latency_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

// SubscribeClient is the client API for Subscribe service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SubscribeClient interface {
	UpdateSub(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	GetSubLinks(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Links, error)
	AddSubLink(ctx context.Context, in *Link, opts ...grpc.CallOption) (*Links, error)
	DeleteSubLink(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*Links, error)
}

type subscribeClient struct {
	cc grpc.ClientConnInterface
}

func NewSubscribeClient(cc grpc.ClientConnInterface) SubscribeClient {
	return &subscribeClient{cc}
}

func (c *subscribeClient) UpdateSub(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Subscribe/UpdateSub", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscribeClient) GetSubLinks(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Links, error) {
	out := new(Links)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Subscribe/GetSubLinks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscribeClient) AddSubLink(ctx context.Context, in *Link, opts ...grpc.CallOption) (*Links, error) {
	out := new(Links)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Subscribe/AddSubLink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscribeClient) DeleteSubLink(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*Links, error) {
	out := new(Links)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Subscribe/DeleteSubLink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SubscribeServer is the server API for Subscribe service.
type SubscribeServer interface {
	UpdateSub(context.Context, *empty.Empty) (*empty.Empty, error)
	GetSubLinks(context.Context, *empty.Empty) (*Links, error)
	AddSubLink(context.Context, *Link) (*Links, error)
	DeleteSubLink(context.Context, *wrappers.StringValue) (*Links, error)
}

// UnimplementedSubscribeServer can be embedded to have forward compatible implementations.
type UnimplementedSubscribeServer struct {
}

func (*UnimplementedSubscribeServer) UpdateSub(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSub not implemented")
}
func (*UnimplementedSubscribeServer) GetSubLinks(ctx context.Context, req *empty.Empty) (*Links, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubLinks not implemented")
}
func (*UnimplementedSubscribeServer) AddSubLink(ctx context.Context, req *Link) (*Links, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddSubLink not implemented")
}
func (*UnimplementedSubscribeServer) DeleteSubLink(ctx context.Context, req *wrappers.StringValue) (*Links, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSubLink not implemented")
}

func RegisterSubscribeServer(s *grpc.Server, srv SubscribeServer) {
	s.RegisterService(&_Subscribe_serviceDesc, srv)
}

func _Subscribe_UpdateSub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscribeServer).UpdateSub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Subscribe/UpdateSub",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscribeServer).UpdateSub(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subscribe_GetSubLinks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscribeServer).GetSubLinks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Subscribe/GetSubLinks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscribeServer).GetSubLinks(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subscribe_AddSubLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Link)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscribeServer).AddSubLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Subscribe/AddSubLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscribeServer).AddSubLink(ctx, req.(*Link))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subscribe_DeleteSubLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrappers.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscribeServer).DeleteSubLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Subscribe/DeleteSubLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscribeServer).DeleteSubLink(ctx, req.(*wrappers.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

var _Subscribe_serviceDesc = grpc.ServiceDesc{
	ServiceName: "yuhaiin.api.Subscribe",
	HandlerType: (*SubscribeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateSub",
			Handler:    _Subscribe_UpdateSub_Handler,
		},
		{
			MethodName: "GetSubLinks",
			Handler:    _Subscribe_GetSubLinks_Handler,
		},
		{
			MethodName: "AddSubLink",
			Handler:    _Subscribe_AddSubLink_Handler,
		},
		{
			MethodName: "DeleteSubLink",
			Handler:    _Subscribe_DeleteSubLink_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

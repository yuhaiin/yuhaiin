// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.1
// source: api/config.proto

package api

import (
	context "context"
	config "github.com/Asutorufa/yuhaiin/pkg/protos/config"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ConfigService_Load_FullMethodName = "/yuhaiin.api.config.config_service/load"
	ConfigService_Save_FullMethodName = "/yuhaiin.api.config.config_service/save"
	ConfigService_Info_FullMethodName = "/yuhaiin.api.config.config_service/info"
)

// ConfigServiceClient is the client API for ConfigService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConfigServiceClient interface {
	Load(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*config.Setting, error)
	Save(ctx context.Context, in *config.Setting, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Info(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*config.Info, error)
}

type configServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConfigServiceClient(cc grpc.ClientConnInterface) ConfigServiceClient {
	return &configServiceClient{cc}
}

func (c *configServiceClient) Load(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*config.Setting, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(config.Setting)
	err := c.cc.Invoke(ctx, ConfigService_Load_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) Save(ctx context.Context, in *config.Setting, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ConfigService_Save_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) Info(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*config.Info, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(config.Info)
	err := c.cc.Invoke(ctx, ConfigService_Info_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConfigServiceServer is the server API for ConfigService service.
// All implementations must embed UnimplementedConfigServiceServer
// for forward compatibility.
type ConfigServiceServer interface {
	Load(context.Context, *emptypb.Empty) (*config.Setting, error)
	Save(context.Context, *config.Setting) (*emptypb.Empty, error)
	Info(context.Context, *emptypb.Empty) (*config.Info, error)
	mustEmbedUnimplementedConfigServiceServer()
}

// UnimplementedConfigServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConfigServiceServer struct{}

func (UnimplementedConfigServiceServer) Load(context.Context, *emptypb.Empty) (*config.Setting, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Load not implemented")
}
func (UnimplementedConfigServiceServer) Save(context.Context, *config.Setting) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Save not implemented")
}
func (UnimplementedConfigServiceServer) Info(context.Context, *emptypb.Empty) (*config.Info, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Info not implemented")
}
func (UnimplementedConfigServiceServer) mustEmbedUnimplementedConfigServiceServer() {}
func (UnimplementedConfigServiceServer) testEmbeddedByValue()                       {}

// UnsafeConfigServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConfigServiceServer will
// result in compilation errors.
type UnsafeConfigServiceServer interface {
	mustEmbedUnimplementedConfigServiceServer()
}

func RegisterConfigServiceServer(s grpc.ServiceRegistrar, srv ConfigServiceServer) {
	// If the following call pancis, it indicates UnimplementedConfigServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConfigService_ServiceDesc, srv)
}

func _ConfigService_Load_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).Load(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigService_Load_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).Load(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_Save_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(config.Setting)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).Save(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigService_Save_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).Save(ctx, req.(*config.Setting))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigService_Info_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).Info(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// ConfigService_ServiceDesc is the grpc.ServiceDesc for ConfigService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConfigService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "yuhaiin.api.config.config_service",
	HandlerType: (*ConfigServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "load",
			Handler:    _ConfigService_Load_Handler,
		},
		{
			MethodName: "save",
			Handler:    _ConfigService_Save_Handler,
		},
		{
			MethodName: "info",
			Handler:    _ConfigService_Info_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/config.proto",
}

const (
	Lists_List_FullMethodName       = "/yuhaiin.api.config.lists/list"
	Lists_Get_FullMethodName        = "/yuhaiin.api.config.lists/get"
	Lists_Save_FullMethodName       = "/yuhaiin.api.config.lists/save"
	Lists_Remove_FullMethodName     = "/yuhaiin.api.config.lists/remove"
	Lists_Refresh_FullMethodName    = "/yuhaiin.api.config.lists/refresh"
	Lists_SaveConfig_FullMethodName = "/yuhaiin.api.config.lists/save_config"
)

// ListsClient is the client API for Lists service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ListsClient interface {
	List(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListResponse, error)
	Get(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*config.List, error)
	Save(ctx context.Context, in *config.List, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Remove(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Refresh(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SaveConfig(ctx context.Context, in *SaveListConfigRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type listsClient struct {
	cc grpc.ClientConnInterface
}

func NewListsClient(cc grpc.ClientConnInterface) ListsClient {
	return &listsClient{cc}
}

func (c *listsClient) List(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListResponse)
	err := c.cc.Invoke(ctx, Lists_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listsClient) Get(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*config.List, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(config.List)
	err := c.cc.Invoke(ctx, Lists_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listsClient) Save(ctx context.Context, in *config.List, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Lists_Save_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listsClient) Remove(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Lists_Remove_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listsClient) Refresh(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Lists_Refresh_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listsClient) SaveConfig(ctx context.Context, in *SaveListConfigRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Lists_SaveConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ListsServer is the server API for Lists service.
// All implementations must embed UnimplementedListsServer
// for forward compatibility.
type ListsServer interface {
	List(context.Context, *emptypb.Empty) (*ListResponse, error)
	Get(context.Context, *wrapperspb.StringValue) (*config.List, error)
	Save(context.Context, *config.List) (*emptypb.Empty, error)
	Remove(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error)
	Refresh(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	SaveConfig(context.Context, *SaveListConfigRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedListsServer()
}

// UnimplementedListsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedListsServer struct{}

func (UnimplementedListsServer) List(context.Context, *emptypb.Empty) (*ListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedListsServer) Get(context.Context, *wrapperspb.StringValue) (*config.List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedListsServer) Save(context.Context, *config.List) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Save not implemented")
}
func (UnimplementedListsServer) Remove(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Remove not implemented")
}
func (UnimplementedListsServer) Refresh(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Refresh not implemented")
}
func (UnimplementedListsServer) SaveConfig(context.Context, *SaveListConfigRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveConfig not implemented")
}
func (UnimplementedListsServer) mustEmbedUnimplementedListsServer() {}
func (UnimplementedListsServer) testEmbeddedByValue()               {}

// UnsafeListsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ListsServer will
// result in compilation errors.
type UnsafeListsServer interface {
	mustEmbedUnimplementedListsServer()
}

func RegisterListsServer(s grpc.ServiceRegistrar, srv ListsServer) {
	// If the following call pancis, it indicates UnimplementedListsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Lists_ServiceDesc, srv)
}

func _Lists_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lists_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListsServer).List(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lists_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lists_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListsServer).Get(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lists_Save_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(config.List)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListsServer).Save(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lists_Save_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListsServer).Save(ctx, req.(*config.List))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lists_Remove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListsServer).Remove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lists_Remove_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListsServer).Remove(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lists_Refresh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListsServer).Refresh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lists_Refresh_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListsServer).Refresh(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lists_SaveConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveListConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListsServer).SaveConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lists_SaveConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListsServer).SaveConfig(ctx, req.(*SaveListConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Lists_ServiceDesc is the grpc.ServiceDesc for Lists service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Lists_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "yuhaiin.api.config.lists",
	HandlerType: (*ListsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "list",
			Handler:    _Lists_List_Handler,
		},
		{
			MethodName: "get",
			Handler:    _Lists_Get_Handler,
		},
		{
			MethodName: "save",
			Handler:    _Lists_Save_Handler,
		},
		{
			MethodName: "remove",
			Handler:    _Lists_Remove_Handler,
		},
		{
			MethodName: "refresh",
			Handler:    _Lists_Refresh_Handler,
		},
		{
			MethodName: "save_config",
			Handler:    _Lists_SaveConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/config.proto",
}

const (
	Rules_List_FullMethodName           = "/yuhaiin.api.config.rules/list"
	Rules_Get_FullMethodName            = "/yuhaiin.api.config.rules/get"
	Rules_Save_FullMethodName           = "/yuhaiin.api.config.rules/save"
	Rules_Remove_FullMethodName         = "/yuhaiin.api.config.rules/remove"
	Rules_ChangePriority_FullMethodName = "/yuhaiin.api.config.rules/change_priority"
	Rules_Config_FullMethodName         = "/yuhaiin.api.config.rules/config"
	Rules_SaveConfig_FullMethodName     = "/yuhaiin.api.config.rules/save_config"
	Rules_Test_FullMethodName           = "/yuhaiin.api.config.rules/test"
	Rules_BlockHistory_FullMethodName   = "/yuhaiin.api.config.rules/block_history"
)

// RulesClient is the client API for Rules service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RulesClient interface {
	List(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*RuleResponse, error)
	Get(ctx context.Context, in *RuleIndex, opts ...grpc.CallOption) (*config.Rulev2, error)
	Save(ctx context.Context, in *RuleSaveRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Remove(ctx context.Context, in *RuleIndex, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ChangePriority(ctx context.Context, in *ChangePriorityRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Config(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*config.Configv2, error)
	SaveConfig(ctx context.Context, in *config.Configv2, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Test(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*TestResponse, error)
	BlockHistory(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*BlockHistoryList, error)
}

type rulesClient struct {
	cc grpc.ClientConnInterface
}

func NewRulesClient(cc grpc.ClientConnInterface) RulesClient {
	return &rulesClient{cc}
}

func (c *rulesClient) List(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*RuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RuleResponse)
	err := c.cc.Invoke(ctx, Rules_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) Get(ctx context.Context, in *RuleIndex, opts ...grpc.CallOption) (*config.Rulev2, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(config.Rulev2)
	err := c.cc.Invoke(ctx, Rules_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) Save(ctx context.Context, in *RuleSaveRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rules_Save_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) Remove(ctx context.Context, in *RuleIndex, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rules_Remove_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) ChangePriority(ctx context.Context, in *ChangePriorityRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rules_ChangePriority_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) Config(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*config.Configv2, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(config.Configv2)
	err := c.cc.Invoke(ctx, Rules_Config_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) SaveConfig(ctx context.Context, in *config.Configv2, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rules_SaveConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) Test(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*TestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestResponse)
	err := c.cc.Invoke(ctx, Rules_Test_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) BlockHistory(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*BlockHistoryList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlockHistoryList)
	err := c.cc.Invoke(ctx, Rules_BlockHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RulesServer is the server API for Rules service.
// All implementations must embed UnimplementedRulesServer
// for forward compatibility.
type RulesServer interface {
	List(context.Context, *emptypb.Empty) (*RuleResponse, error)
	Get(context.Context, *RuleIndex) (*config.Rulev2, error)
	Save(context.Context, *RuleSaveRequest) (*emptypb.Empty, error)
	Remove(context.Context, *RuleIndex) (*emptypb.Empty, error)
	ChangePriority(context.Context, *ChangePriorityRequest) (*emptypb.Empty, error)
	Config(context.Context, *emptypb.Empty) (*config.Configv2, error)
	SaveConfig(context.Context, *config.Configv2) (*emptypb.Empty, error)
	Test(context.Context, *wrapperspb.StringValue) (*TestResponse, error)
	BlockHistory(context.Context, *emptypb.Empty) (*BlockHistoryList, error)
	mustEmbedUnimplementedRulesServer()
}

// UnimplementedRulesServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRulesServer struct{}

func (UnimplementedRulesServer) List(context.Context, *emptypb.Empty) (*RuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRulesServer) Get(context.Context, *RuleIndex) (*config.Rulev2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRulesServer) Save(context.Context, *RuleSaveRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Save not implemented")
}
func (UnimplementedRulesServer) Remove(context.Context, *RuleIndex) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Remove not implemented")
}
func (UnimplementedRulesServer) ChangePriority(context.Context, *ChangePriorityRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangePriority not implemented")
}
func (UnimplementedRulesServer) Config(context.Context, *emptypb.Empty) (*config.Configv2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Config not implemented")
}
func (UnimplementedRulesServer) SaveConfig(context.Context, *config.Configv2) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveConfig not implemented")
}
func (UnimplementedRulesServer) Test(context.Context, *wrapperspb.StringValue) (*TestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Test not implemented")
}
func (UnimplementedRulesServer) BlockHistory(context.Context, *emptypb.Empty) (*BlockHistoryList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockHistory not implemented")
}
func (UnimplementedRulesServer) mustEmbedUnimplementedRulesServer() {}
func (UnimplementedRulesServer) testEmbeddedByValue()               {}

// UnsafeRulesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RulesServer will
// result in compilation errors.
type UnsafeRulesServer interface {
	mustEmbedUnimplementedRulesServer()
}

func RegisterRulesServer(s grpc.ServiceRegistrar, srv RulesServer) {
	// If the following call pancis, it indicates UnimplementedRulesServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Rules_ServiceDesc, srv)
}

func _Rules_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rules_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).List(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleIndex)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rules_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).Get(ctx, req.(*RuleIndex))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_Save_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleSaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).Save(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rules_Save_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).Save(ctx, req.(*RuleSaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_Remove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleIndex)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).Remove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rules_Remove_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).Remove(ctx, req.(*RuleIndex))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_ChangePriority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangePriorityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).ChangePriority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rules_ChangePriority_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).ChangePriority(ctx, req.(*ChangePriorityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_Config_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).Config(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rules_Config_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).Config(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_SaveConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(config.Configv2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).SaveConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rules_SaveConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).SaveConfig(ctx, req.(*config.Configv2))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_Test_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).Test(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rules_Test_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).Test(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_BlockHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).BlockHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rules_BlockHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).BlockHistory(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Rules_ServiceDesc is the grpc.ServiceDesc for Rules service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Rules_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "yuhaiin.api.config.rules",
	HandlerType: (*RulesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "list",
			Handler:    _Rules_List_Handler,
		},
		{
			MethodName: "get",
			Handler:    _Rules_Get_Handler,
		},
		{
			MethodName: "save",
			Handler:    _Rules_Save_Handler,
		},
		{
			MethodName: "remove",
			Handler:    _Rules_Remove_Handler,
		},
		{
			MethodName: "change_priority",
			Handler:    _Rules_ChangePriority_Handler,
		},
		{
			MethodName: "config",
			Handler:    _Rules_Config_Handler,
		},
		{
			MethodName: "save_config",
			Handler:    _Rules_SaveConfig_Handler,
		},
		{
			MethodName: "test",
			Handler:    _Rules_Test_Handler,
		},
		{
			MethodName: "block_history",
			Handler:    _Rules_BlockHistory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/config.proto",
}

const (
	Inbound_List_FullMethodName         = "/yuhaiin.api.config.inbound/list"
	Inbound_Get_FullMethodName          = "/yuhaiin.api.config.inbound/get"
	Inbound_Save_FullMethodName         = "/yuhaiin.api.config.inbound/save"
	Inbound_Remove_FullMethodName       = "/yuhaiin.api.config.inbound/remove"
	Inbound_Apply_FullMethodName        = "/yuhaiin.api.config.inbound/apply"
	Inbound_PlatformInfo_FullMethodName = "/yuhaiin.api.config.inbound/platform_info"
)

// InboundClient is the client API for Inbound service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InboundClient interface {
	List(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*InboundsResponse, error)
	Get(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*config.Inbound, error)
	Save(ctx context.Context, in *config.Inbound, opts ...grpc.CallOption) (*config.Inbound, error)
	Remove(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Apply(ctx context.Context, in *InboundsResponse, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PlatformInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PlatformInfoResponse, error)
}

type inboundClient struct {
	cc grpc.ClientConnInterface
}

func NewInboundClient(cc grpc.ClientConnInterface) InboundClient {
	return &inboundClient{cc}
}

func (c *inboundClient) List(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*InboundsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InboundsResponse)
	err := c.cc.Invoke(ctx, Inbound_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inboundClient) Get(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*config.Inbound, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(config.Inbound)
	err := c.cc.Invoke(ctx, Inbound_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inboundClient) Save(ctx context.Context, in *config.Inbound, opts ...grpc.CallOption) (*config.Inbound, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(config.Inbound)
	err := c.cc.Invoke(ctx, Inbound_Save_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inboundClient) Remove(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Inbound_Remove_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inboundClient) Apply(ctx context.Context, in *InboundsResponse, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Inbound_Apply_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inboundClient) PlatformInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PlatformInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PlatformInfoResponse)
	err := c.cc.Invoke(ctx, Inbound_PlatformInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InboundServer is the server API for Inbound service.
// All implementations must embed UnimplementedInboundServer
// for forward compatibility.
type InboundServer interface {
	List(context.Context, *emptypb.Empty) (*InboundsResponse, error)
	Get(context.Context, *wrapperspb.StringValue) (*config.Inbound, error)
	Save(context.Context, *config.Inbound) (*config.Inbound, error)
	Remove(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error)
	Apply(context.Context, *InboundsResponse) (*emptypb.Empty, error)
	PlatformInfo(context.Context, *emptypb.Empty) (*PlatformInfoResponse, error)
	mustEmbedUnimplementedInboundServer()
}

// UnimplementedInboundServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedInboundServer struct{}

func (UnimplementedInboundServer) List(context.Context, *emptypb.Empty) (*InboundsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedInboundServer) Get(context.Context, *wrapperspb.StringValue) (*config.Inbound, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedInboundServer) Save(context.Context, *config.Inbound) (*config.Inbound, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Save not implemented")
}
func (UnimplementedInboundServer) Remove(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Remove not implemented")
}
func (UnimplementedInboundServer) Apply(context.Context, *InboundsResponse) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Apply not implemented")
}
func (UnimplementedInboundServer) PlatformInfo(context.Context, *emptypb.Empty) (*PlatformInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlatformInfo not implemented")
}
func (UnimplementedInboundServer) mustEmbedUnimplementedInboundServer() {}
func (UnimplementedInboundServer) testEmbeddedByValue()                 {}

// UnsafeInboundServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InboundServer will
// result in compilation errors.
type UnsafeInboundServer interface {
	mustEmbedUnimplementedInboundServer()
}

func RegisterInboundServer(s grpc.ServiceRegistrar, srv InboundServer) {
	// If the following call pancis, it indicates UnimplementedInboundServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Inbound_ServiceDesc, srv)
}

func _Inbound_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InboundServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Inbound_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InboundServer).List(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inbound_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InboundServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Inbound_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InboundServer).Get(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inbound_Save_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(config.Inbound)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InboundServer).Save(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Inbound_Save_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InboundServer).Save(ctx, req.(*config.Inbound))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inbound_Remove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InboundServer).Remove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Inbound_Remove_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InboundServer).Remove(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inbound_Apply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InboundsResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InboundServer).Apply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Inbound_Apply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InboundServer).Apply(ctx, req.(*InboundsResponse))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inbound_PlatformInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InboundServer).PlatformInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Inbound_PlatformInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InboundServer).PlatformInfo(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Inbound_ServiceDesc is the grpc.ServiceDesc for Inbound service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Inbound_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "yuhaiin.api.config.inbound",
	HandlerType: (*InboundServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "list",
			Handler:    _Inbound_List_Handler,
		},
		{
			MethodName: "get",
			Handler:    _Inbound_Get_Handler,
		},
		{
			MethodName: "save",
			Handler:    _Inbound_Save_Handler,
		},
		{
			MethodName: "remove",
			Handler:    _Inbound_Remove_Handler,
		},
		{
			MethodName: "apply",
			Handler:    _Inbound_Apply_Handler,
		},
		{
			MethodName: "platform_info",
			Handler:    _Inbound_PlatformInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/config.proto",
}

const (
	Resolver_List_FullMethodName        = "/yuhaiin.api.config.resolver/list"
	Resolver_Get_FullMethodName         = "/yuhaiin.api.config.resolver/get"
	Resolver_Save_FullMethodName        = "/yuhaiin.api.config.resolver/save"
	Resolver_Remove_FullMethodName      = "/yuhaiin.api.config.resolver/remove"
	Resolver_Hosts_FullMethodName       = "/yuhaiin.api.config.resolver/hosts"
	Resolver_SaveHosts_FullMethodName   = "/yuhaiin.api.config.resolver/save_hosts"
	Resolver_Fakedns_FullMethodName     = "/yuhaiin.api.config.resolver/fakedns"
	Resolver_SaveFakedns_FullMethodName = "/yuhaiin.api.config.resolver/save_fakedns"
	Resolver_Server_FullMethodName      = "/yuhaiin.api.config.resolver/server"
	Resolver_SaveServer_FullMethodName  = "/yuhaiin.api.config.resolver/save_server"
)

// ResolverClient is the client API for Resolver service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ResolverClient interface {
	List(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ResolveList, error)
	Get(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*config.Dns, error)
	Save(ctx context.Context, in *SaveResolver, opts ...grpc.CallOption) (*config.Dns, error)
	// the bootstrap can't be remove
	Remove(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Hosts(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Hosts, error)
	SaveHosts(ctx context.Context, in *Hosts, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Fakedns(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*config.FakednsConfig, error)
	SaveFakedns(ctx context.Context, in *config.FakednsConfig, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Server(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	SaveServer(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type resolverClient struct {
	cc grpc.ClientConnInterface
}

func NewResolverClient(cc grpc.ClientConnInterface) ResolverClient {
	return &resolverClient{cc}
}

func (c *resolverClient) List(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ResolveList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResolveList)
	err := c.cc.Invoke(ctx, Resolver_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resolverClient) Get(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*config.Dns, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(config.Dns)
	err := c.cc.Invoke(ctx, Resolver_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resolverClient) Save(ctx context.Context, in *SaveResolver, opts ...grpc.CallOption) (*config.Dns, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(config.Dns)
	err := c.cc.Invoke(ctx, Resolver_Save_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resolverClient) Remove(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Resolver_Remove_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resolverClient) Hosts(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Hosts, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Hosts)
	err := c.cc.Invoke(ctx, Resolver_Hosts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resolverClient) SaveHosts(ctx context.Context, in *Hosts, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Resolver_SaveHosts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resolverClient) Fakedns(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*config.FakednsConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(config.FakednsConfig)
	err := c.cc.Invoke(ctx, Resolver_Fakedns_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resolverClient) SaveFakedns(ctx context.Context, in *config.FakednsConfig, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Resolver_SaveFakedns_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resolverClient) Server(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, Resolver_Server_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resolverClient) SaveServer(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Resolver_SaveServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ResolverServer is the server API for Resolver service.
// All implementations must embed UnimplementedResolverServer
// for forward compatibility.
type ResolverServer interface {
	List(context.Context, *emptypb.Empty) (*ResolveList, error)
	Get(context.Context, *wrapperspb.StringValue) (*config.Dns, error)
	Save(context.Context, *SaveResolver) (*config.Dns, error)
	// the bootstrap can't be remove
	Remove(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error)
	Hosts(context.Context, *emptypb.Empty) (*Hosts, error)
	SaveHosts(context.Context, *Hosts) (*emptypb.Empty, error)
	Fakedns(context.Context, *emptypb.Empty) (*config.FakednsConfig, error)
	SaveFakedns(context.Context, *config.FakednsConfig) (*emptypb.Empty, error)
	Server(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error)
	SaveServer(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error)
	mustEmbedUnimplementedResolverServer()
}

// UnimplementedResolverServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedResolverServer struct{}

func (UnimplementedResolverServer) List(context.Context, *emptypb.Empty) (*ResolveList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedResolverServer) Get(context.Context, *wrapperspb.StringValue) (*config.Dns, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedResolverServer) Save(context.Context, *SaveResolver) (*config.Dns, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Save not implemented")
}
func (UnimplementedResolverServer) Remove(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Remove not implemented")
}
func (UnimplementedResolverServer) Hosts(context.Context, *emptypb.Empty) (*Hosts, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Hosts not implemented")
}
func (UnimplementedResolverServer) SaveHosts(context.Context, *Hosts) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveHosts not implemented")
}
func (UnimplementedResolverServer) Fakedns(context.Context, *emptypb.Empty) (*config.FakednsConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Fakedns not implemented")
}
func (UnimplementedResolverServer) SaveFakedns(context.Context, *config.FakednsConfig) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveFakedns not implemented")
}
func (UnimplementedResolverServer) Server(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Server not implemented")
}
func (UnimplementedResolverServer) SaveServer(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveServer not implemented")
}
func (UnimplementedResolverServer) mustEmbedUnimplementedResolverServer() {}
func (UnimplementedResolverServer) testEmbeddedByValue()                  {}

// UnsafeResolverServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ResolverServer will
// result in compilation errors.
type UnsafeResolverServer interface {
	mustEmbedUnimplementedResolverServer()
}

func RegisterResolverServer(s grpc.ServiceRegistrar, srv ResolverServer) {
	// If the following call pancis, it indicates UnimplementedResolverServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Resolver_ServiceDesc, srv)
}

func _Resolver_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResolverServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Resolver_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResolverServer).List(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Resolver_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResolverServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Resolver_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResolverServer).Get(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Resolver_Save_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveResolver)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResolverServer).Save(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Resolver_Save_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResolverServer).Save(ctx, req.(*SaveResolver))
	}
	return interceptor(ctx, in, info, handler)
}

func _Resolver_Remove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResolverServer).Remove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Resolver_Remove_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResolverServer).Remove(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Resolver_Hosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResolverServer).Hosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Resolver_Hosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResolverServer).Hosts(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Resolver_SaveHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Hosts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResolverServer).SaveHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Resolver_SaveHosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResolverServer).SaveHosts(ctx, req.(*Hosts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Resolver_Fakedns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResolverServer).Fakedns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Resolver_Fakedns_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResolverServer).Fakedns(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Resolver_SaveFakedns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(config.FakednsConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResolverServer).SaveFakedns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Resolver_SaveFakedns_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResolverServer).SaveFakedns(ctx, req.(*config.FakednsConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _Resolver_Server_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResolverServer).Server(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Resolver_Server_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResolverServer).Server(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Resolver_SaveServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResolverServer).SaveServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Resolver_SaveServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResolverServer).SaveServer(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

// Resolver_ServiceDesc is the grpc.ServiceDesc for Resolver service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Resolver_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "yuhaiin.api.config.resolver",
	HandlerType: (*ResolverServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "list",
			Handler:    _Resolver_List_Handler,
		},
		{
			MethodName: "get",
			Handler:    _Resolver_Get_Handler,
		},
		{
			MethodName: "save",
			Handler:    _Resolver_Save_Handler,
		},
		{
			MethodName: "remove",
			Handler:    _Resolver_Remove_Handler,
		},
		{
			MethodName: "hosts",
			Handler:    _Resolver_Hosts_Handler,
		},
		{
			MethodName: "save_hosts",
			Handler:    _Resolver_SaveHosts_Handler,
		},
		{
			MethodName: "fakedns",
			Handler:    _Resolver_Fakedns_Handler,
		},
		{
			MethodName: "save_fakedns",
			Handler:    _Resolver_SaveFakedns_Handler,
		},
		{
			MethodName: "server",
			Handler:    _Resolver_Server_Handler,
		},
		{
			MethodName: "save_server",
			Handler:    _Resolver_SaveServer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/config.proto",
}

// Code generated by bpf2go; DO NOT EDIT.
//go:build (mips || mips64 || ppc64 || s390x) && linux

package tcplife

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

// loadTcplife returns the embedded CollectionSpec for tcplife.
func loadTcplife() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_TcplifeBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load tcplife: %w", err)
	}

	return spec, err
}

// loadTcplifeObjects loads tcplife and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*tcplifeObjects
//	*tcplifePrograms
//	*tcplifeMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadTcplifeObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadTcplife()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// tcplifeSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type tcplifeSpecs struct {
	tcplifeProgramSpecs
	tcplifeMapSpecs
	tcplifeVariableSpecs
}

// tcplifeProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type tcplifeProgramSpecs struct {
	InetBind           *ebpf.ProgramSpec `ebpf:"inet_bind"`
	InetBindExit       *ebpf.ProgramSpec `ebpf:"inet_bind_exit"`
	SocketBind         *ebpf.ProgramSpec `ebpf:"socket_bind"`
	TcpClose           *ebpf.ProgramSpec `ebpf:"tcp_close"`
	TcpConnect         *ebpf.ProgramSpec `ebpf:"tcp_connect"`
	TpInetSockSetState *ebpf.ProgramSpec `ebpf:"tp_inet_sock_set_state"`
	UdpBind            *ebpf.ProgramSpec `ebpf:"udp_bind"`
}

// tcplifeMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type tcplifeMapSpecs struct {
	Events *ebpf.MapSpec `ebpf:"events"`
}

// tcplifeVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type tcplifeVariableSpecs struct {
}

// tcplifeObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadTcplifeObjects or ebpf.CollectionSpec.LoadAndAssign.
type tcplifeObjects struct {
	tcplifePrograms
	tcplifeMaps
	tcplifeVariables
}

func (o *tcplifeObjects) Close() error {
	return _TcplifeClose(
		&o.tcplifePrograms,
		&o.tcplifeMaps,
	)
}

// tcplifeMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadTcplifeObjects or ebpf.CollectionSpec.LoadAndAssign.
type tcplifeMaps struct {
	Events *ebpf.Map `ebpf:"events"`
}

func (m *tcplifeMaps) Close() error {
	return _TcplifeClose(
		m.Events,
	)
}

// tcplifeVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to loadTcplifeObjects or ebpf.CollectionSpec.LoadAndAssign.
type tcplifeVariables struct {
}

// tcplifePrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadTcplifeObjects or ebpf.CollectionSpec.LoadAndAssign.
type tcplifePrograms struct {
	InetBind           *ebpf.Program `ebpf:"inet_bind"`
	InetBindExit       *ebpf.Program `ebpf:"inet_bind_exit"`
	SocketBind         *ebpf.Program `ebpf:"socket_bind"`
	TcpClose           *ebpf.Program `ebpf:"tcp_close"`
	TcpConnect         *ebpf.Program `ebpf:"tcp_connect"`
	TpInetSockSetState *ebpf.Program `ebpf:"tp_inet_sock_set_state"`
	UdpBind            *ebpf.Program `ebpf:"udp_bind"`
}

func (p *tcplifePrograms) Close() error {
	return _TcplifeClose(
		p.InetBind,
		p.InetBindExit,
		p.SocketBind,
		p.TcpClose,
		p.TcpConnect,
		p.TpInetSockSetState,
		p.UdpBind,
	)
}

func _TcplifeClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed tcplife_bpfeb.o
var _TcplifeBytes []byte
